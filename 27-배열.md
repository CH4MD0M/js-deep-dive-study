# 배열이란?

배열은 여러 개의 값을 순차적으로 나열한 자료구조다.

배열이 가지고 있는 값을 **요소(Element)** 라고 부른다. 자바스크립트의 모든 값은 배열의 요소가 될 수 있다. 배열은 요소의 개수, 즉 배열의 길이를 나타내는 **`length` 프로퍼티**를 갖는다.

자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.

```jsx
const arr = [1, 2, 3];
console.log(typeof arr); // object
```

**_일반 객체와 배열의 차이는 값의 순서와 length 프로퍼티다._**

<br><br>

# 자바스크립트 배열은 배열이 아니다

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다.

배열의 요소가 하나의 데이터 타입으로 통일되어 있고 연속적으로 인접해 있는 배열을 **밀집 배열(dense array)** 이라 한다.

자바스크립트의 배열은 자료구조에서 말하는 일반적인 배열과는 다르다. 자바스크립트의 배열은 배열 요소의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 이러한 배열을 **희소배열(sparse array)** 이라 한다.

**_자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다._**

<br>

```jsx
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]));
/* 
{
  '0': { value: 1, writable: true, enumerable: true, configurable: true },
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  '2': { value: 3, writable: true, enumerable: true, configurable: true },
  length: { value: 3, writable: true, enumerable: false, configurable: false }
}
 */
```

**자바스크립트 배열은 인덱스 문자열을 프로퍼티 키로 가지며, `length` 프로퍼티를 갖는 특수한 객체다.** 자바스크립트 배열의 요소는 사실 프로퍼티 값이다. 자바스크립트에서 사용할 수 있는 모든 값은 객체의 프로퍼티 값이 될 수 있으므로 **_어떤 타입의 값이라도 배열의 요소가 될 수 있다._**

<br>

자바스크립트 배열은 인덱스로 배열 요소에 접근하는 경우에는 일반적인 배열봐 느리지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적이 배열보다 빠르다.

자바스크립트 배열은 **`해시 테이블`** 로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느릴 수밖에 없는 구조적인 단점이 있다.

<br><br>

# length 프로퍼티와 희소 배열

**`length`** 프로퍼티는 **배열의 길이**를 나타내는 0이상의 정수를 값으로 갖는다.

**`length`** 프로퍼티 값은 **배열의 길이**를 바탕으로 결정되지만, **_임의의 숫자 값을 명시적으로 할당할 수 있다._**

<br>

현재 length 프로퍼티 값보다 작은 값을 할당하면 배열의 길이가 줄어든다.

```jsx
const arr = [1, 2, 3, 4, 5];

arr.length = 3;

// 배열의 길이가 5에서 3으로 줄어든다.
console.log(arr); // [1, 2, 3]
```

<br>

현재 length 프로퍼티 값보다 큰 값을 할당하면 length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.

```jsx
const arr = [1];

arr.length = 3;

// length 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지는 않는다.
console.log(arr.length); // 3
console.log(arr); // [1, empty × 2]
```

empty × 2는 실제로 추가된 배열의 요소가 아니다. arr[1]과 arr[2]에는 값이 존재하지 않는다.

<br>

```jsx
console.log(Object.getOwnPropertyDescriptors(arr));
/* 
{
  '0': { value: 1, writable: true, enumerable: true, configurable: true },
  length: { value: 3, writable: true, enumerable: false, configurable: false }
}
 */
```

이처럼 배열의 요소가 연속적으로 위치하지 않고 일부가 비어 있는 배열을 **`희소 배열`** 이라 한다.

일반적인 배열의 length는 배열의 길이와 언제나 일치한다. 하지만 희소 배열은 length와 배열 요소의 개수가 일치하지 않는다. **_희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다._**

<br>

**_자바스크립트는 문법적으로 희소 배열을 허용하지만 희소 배열은 사용하지 않는 것이 좋다._** 의도적으로 희소 배열을 만들어여 하는 상황은 발생하지 않는다. 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.

<br><br>

# 배열 생성

### 배열 리터럴

```jsx
const arr = [1, 2, 3];
console.log(arr.length); // 3
```

배열 리터럴은 0개 이상의 요소를 쉼표로 구분하여 **대괄호([ ])** 로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재한다.

<br>

### Array 생성자 함수

Array 생성자 함수는 전달된 인수의 개수에 따라 다르게 동작한다.

**전달된 인수가 1개이고 숫자인 경우** length 프로퍼티 값이 인수인 배열을 생성한다. 이때 생성된 배열은 희소 배열이다. length 프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않는다.

```jsx
const arr = new Array(10);

console.log(arr); // [empty × 10]
console.log(arr.length); // 10
```

<br>

**전달된 인수가 2개 이상이거나 숫자가 아닌 경우** 인수를 요소로 갖는 배열을 생성한다.

```jsx
// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.
new Array(1, 2, 3); // [1, 2, 3]

// 전달된 인수가 1개지만 숫자가 아니면 인수를 요소로 갖는 배열을 생성한다.
new Array({}); // [{}]
```

<br>

### Array.of

ES6에서 도입된 **`Array.of`** 메서드는 전달된 인수를 요소라 갖는 배열을 생성한다.

Array.of 메서드는 Array 생성자 함수와 다르게 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.

```jsx
// 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.
Array.of(1); // [1]

Array.of(1, 2, 3); // [1, 2, 3]

Array.of("string"); // ['string']
```

<br>

### Array.from

ES6에서 도입된 **`Array.from`** 메서드는 **유사 배열 객체** 또는 **이터러블 객체**를 인수로 전달받아 배열로 변환하여 반환한다.

```jsx
// 유사 배열 객체를 변환하여 배열을 생성한다.
Array.from({ length: 2, 0: "a", 1: "b" }); // -> ['a', 'b']

// 이터러블을 변환하여 배열을 생성한다. 문자열은 이터러블이다.
Array.from("Hello"); // -> ['H', 'e', 'l', 'l', 'o']
```

<br>

**_Array.from을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다._**

```jsx
// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 }); // [undefined, undefined, undefined]

// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3 }, (_, i) => i); // [0, 1, 2]
```

> ✍🏻 **유사 배열 객체와 이터러블 객체**
>
> **유사 배열 객체(Array-like object)** 는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다. 유사 배열 객체는 마치 배열처럼 **`for`** 문으로 순회할 수도 있다.
>
> **이터러블 객체(Iterable object)** 는 **`Symbol.iterator`** 메서드를 구현하여 **`for…of`** 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말한다.

<br><br>

# 배열 요소의 참조

배열의 요소를 참조할 때에는 **대괄호([ ]) 표기법**을 사용한다.

```jsx
const arr = [1, 2];

console.log(arr[0]); // 1
console.log(arr[1]); // 2
```

존재하지 않는 요소에 접근하면 **`undefined`** 가 반환된다.

```jsx
const arr = [1, 2];

console.log(arr[2]); // undefined
```

<br><br>

# 배열 요소의 추가와 갱신

객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다. 이때 **`length`** 프로퍼티 값은 자동 갱신된다.

```jsx
const arr = [0];

// 배열 요소의 추가
arr[1] = 1;

console.log(arr); // [0, 1]
console.log(arr.length); // 2
```

이미 요소가 존재하는 요소에 값을 할당하면 요소값이 갱신된다.

```jsx
const arr = [0];

// 요소값의 갱신
arr[0] = 1;

console.log(arr); // [1]
```

<br><br>

# 배열 요소의 삭제

```jsx
const arr = [1, 2, 3];

// 배열 요소의 삭제
delete arr[1];
console.log(arr); // [1, empty, 3]

// length 프로퍼티에 영향을 주지 않는다. 즉, 희소 배열이 된다.
console.log(arr.length); // 3
```

자바스크립트의 배열은 객체이기 때문에 배열의 특정 요소를 삭제하기 위해 **`delete`** 연산자를 사용할 수 있다. 이때 배열은 희소 배열이 되며 **`length`** 프로퍼티 값은 변하지 않는다. 따라서 희소 배열을 만드는 **`delete`** 연산자는 사용하지 않는 것이 좋다.

<br>

희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 **`Array.prototype.splice`** 메서드를 사용한다.

```jsx
const arr = [1, 2, 3];

// 배열 요소의 삭제
arr.splice(1, 1);
console.log(arr); // [1, 3]

console.log(arr.length); // 2
```
